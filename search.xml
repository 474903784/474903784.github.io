<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[在Linux下安装JDK8.0]]></title>
      <url>http://474903784.github.io/2016/08/20/%E5%9C%A8Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK8.0/</url>
      <content type="html"><![CDATA[<p>最近项目需要发布，采用集群服务器，现在要把服务器从Windows中转到Linux下，所以在此把Linux的部分服务器环境配置记录下，方便供以后参考。</p>
<h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><p>系统环境：centos-7.2<br>安装方式：rpm安装<br>软件：jdk-8u101-linux-x64.rpm<br>下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<a id="more"></a>
<h3 id="检验系统原版本"><a href="#检验系统原版本" class="headerlink" title="检验系统原版本"></a>检验系统原版本</h3><pre><code># java -version
</code></pre><p><img src="http://i.imgur.com/3eeacSc.png" alt=""></p>
<p>进一步查看JDK信息：   </p>
<pre><code># rpm -qa | grep jdk  
</code></pre><p><img src="http://i.imgur.com/rBfNiHp.png" alt=""></p>
<p>卸载jdk，执行以下操作：</p>
<pre><code># rpm -e -nodeps jdk1.8.0_101-1.8.0_101-fcs.x86_64
</code></pre><h3 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h3><p>进入/usr/java文件夹  </p>
<pre><code># cd /usr/java
</code></pre><p>如果不存在，新建文件夹再进入</p>
<pre><code># mkdir /usr/java
</code></pre><p>使用wget命令下载 JDK8.0  </p>
<pre><code>#wget -c http://download.oracle.com/otn-pub/java/jdk/8u101-b13/jdk-8u101-linux-x64.rpm
</code></pre><p><img src="http://i.imgur.com/shXZGCq.png" alt=""></p>
<h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><pre><code># rpm -ivh jdk-8u101-linux-x64.rpm  
</code></pre><p>JKD默认安装在 /usr/java 中。<br><img src="http://i.imgur.com/a58uRmn.png" alt=""></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>修改系统环境变量文件：</p>
<pre><code># vi /etc/profile
</code></pre><p>向文件里面追加以下内容：</p>
<pre><code>JAVA_HOME=/usr/java/jdk1.8.0_101
JRE_HOME=/usr/java/jdk1.8.0_101/jre
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
export JAVA_HOME JRE_HOME PATH CLASSPATH
</code></pre><p>修改后如下图：<br><img src="http://i.imgur.com/kORPy1H.png" alt=""></p>
<p>为使修改生效，执行以下命令：</p>
<pre><code># source /etc/profile  //使修改立即生效
# echo $PATH   //查看PATH值
</code></pre><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><pre><code># java
# javac
# java -version
</code></pre><p><img src="http://i.imgur.com/3eeacSc.png" alt=""></p>
<h3 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h3><p>a、</p>
<p><img src="http://i.imgur.com/WyT0nwP.png" alt=""></p>
<p>出现此问题，是因为64位系统中安装了32位程序。<br>解决方法：</p>
<pre><code># yum install glibc.i686
</code></pre><p>参考：<a href="http://www.111cn.net/sys/linux/55374.htm" target="_blank" rel="external">http://www.111cn.net/sys/linux/55374.htm</a></p>
<p>b、<br>查询 JDK 版本号</p>
<pre><code># java -version
</code></pre><p>出现以下情况：</p>
<pre><code>Error occurred during initialization of VM
java/lang/NoClassDefFoundError: java/lang/Object
</code></pre><p>是因为/usr/java/jdk/lib目录下没有tools.jar或/usr/java/jre/lib目录下没有rt.jar。（从/usr/java/jdk1.8.0_101/jre/lib目录下复制rt.jar到/usr/java/jre/lib）</p>
<p>解决方法：参考<a href="http://babyhe.blog.51cto.com/1104064/1045485/" target="_blank" rel="external">http://babyhe.blog.51cto.com/1104064/1045485/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初认识中间件之消息服务]]></title>
      <url>http://474903784.github.io/2016/07/25/%E5%88%9D%E8%AF%86%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h3 id="一、消息队列概述"><a href="#一、消息队列概述" class="headerlink" title="一、消息队列概述"></a>一、消息队列概述</h3><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。<br>目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。<br><a id="more"></a></p>
<h3 id="二、消息队列应用场景"><a href="#二、消息队列应用场景" class="headerlink" title="二、消息队列应用场景"></a>二、消息队列应用场景</h3><p>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。</p>
<h4 id="2-1-异步处理"><a href="#2-1-异步处理" class="headerlink" title="2.1 异步处理"></a>2.1 异步处理</h4><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种1.串行的方式；2.并行方式。</p>
<p>（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。<br><img src="http://i.imgur.com/opUoeL3.png" alt=""></p>
<p>（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。<br><img src="http://i.imgur.com/yo0jvuq.png" alt=""></p>
<p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p>
<p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）。</p>
<p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p>
<p>引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：<br><img src="http://i.imgur.com/z2L0QPD.png" alt=""></p>
<h2 id="2-2应用解耦"><a href="#2-2应用解耦" class="headerlink" title="2.2应用解耦"></a>2.2应用解耦</h2><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：<br><img src="http://i.imgur.com/RCmzICK.png" alt=""></p>
<p>传统模式的缺点：</p>
<p>1）  假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；</p>
<p>2）  订单系统与库存系统耦合；</p>
<p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：<br><img src="http://i.imgur.com/wtgjLL0.png" alt=""></p>
<ul>
<li>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</li>
<li>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</li>
<li>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</li>
</ul>
<h2 id="2-3-流量削锋"><a href="#2-3-流量削锋" class="headerlink" title="2.3 流量削锋"></a>2.3 流量削锋</h2><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。<br>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。  </p>
<ol>
<li>可以控制活动的人数；  </li>
<li>可以缓解短时间内高流量压垮应用。  </li>
</ol>
<p><img src="http://i.imgur.com/Z0RWVtD.png" alt=""></p>
<ol>
<li>应用的请求，服务器接收后，首先写入消息队列。加入消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面；  </li>
<li>秒杀业务根据消息队列中的请求信息，再做后续处理。</li>
</ol>
<h2 id="2-4日志处理"><a href="#2-4日志处理" class="headerlink" title="2.4日志处理"></a>2.4日志处理</h2><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：<br><img src="http://i.imgur.com/cKUSVlf.png" alt=""></p>
<ul>
<li>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；  </li>
<li>Kafka消息队列，负责日志数据的接收，存储和转发；  </li>
<li>日志处理应用：订阅并消费kafka队列中的日志数据；  </li>
</ul>
<p>以下是新浪kafka日志处理应用案例：<br><img src="http://i.imgur.com/s84gF9P.png" alt=""></p>
<p>(1)Kafka：接收用户日志的消息队列。</p>
<p>(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。</p>
<p>(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过         index组织数据，兼具强大的搜索和统计功能。</p>
<p>(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。</p>
<h2 id="2-5消息通讯"><a href="#2-5消息通讯" class="headerlink" title="2.5消息通讯"></a>2.5消息通讯</h2><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p>
<p>点对点通讯：<br><img src="http://i.imgur.com/k2YXK6r.png" alt=""></p>
<p>客户端A和客户端B使用同一队列，进行消息通讯。<br>聊天室通讯：<br><img src="http://i.imgur.com/Vi3Punv.png" alt=""></p>
<p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p>
<p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p>
<h3 id="三、消息中间件示例"><a href="#三、消息中间件示例" class="headerlink" title="三、消息中间件示例"></a>三、消息中间件示例</h3><h2 id="3-1-电商系统"><a href="#3-1-电商系统" class="headerlink" title="3.1 电商系统"></a>3.1 电商系统</h2><p><img src="http://i.imgur.com/XJiPchf.jpg" alt=""></p>
<p>消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。  </p>
<ol>
<li>应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）  </li>
<li>扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。  </li>
<li>消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</li>
</ol>
<h2 id="3-2-日志收集系统"><a href="#3-2-日志收集系统" class="headerlink" title="3.2 日志收集系统"></a>3.2 日志收集系统</h2><p><img src="http://i.imgur.com/ASUst1F.jpg" alt=""></p>
<p>分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。</p>
<ul>
<li>Zookeeper注册中心，提出负载均衡和地址查找服务；  </li>
<li>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列；  </li>
<li>Kafka集群：接收，路由，存储，转发等消息处理；  </li>
<li>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据；</li>
</ul>
<hr>
<p>对消息服务的认识，都来自网络上的认识和学习，如果你发现本文有任何的错误或疑问，还请指正，感谢！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『$watch的用法』]]></title>
      <url>http://474903784.github.io/2016/07/23/$watch%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>今天在学习angular.js的时候，遇到$watch的函数，由于菜鸟教程中没有找到此函数，故在此做下笔记。</p>
<h3 id="watch简单使用"><a href="#watch简单使用" class="headerlink" title="$watch简单使用"></a>$watch简单使用</h3><p>$watch是一个scope函数，用于监听模型变化，当你的模型部分发生变化时它会通知你。<br>$watch(watchExpression, listener, objectEquality);</p>
<a id="more"></a>
<p>每个参数的说明如下：</p>
<ol>
<li><p>watchExpression：监听的对象，它可以是一个angular表达式如’name’,或函数如function(){return $scope.name}。</p>
</li>
<li><p>listener:当watchExpression变化时会被调用的函数或者表达式,它接收3个参数：newValue(新值), oldValue(旧值), scope(作用域的引用)。</p>
</li>
<li><p>objectEquality：是否深度监听，如果设置为true,它告诉Angular检查所监控的对象中每一个属性的变化. 如果你希望监控数组的个别元素或者对象的属性而不是一个普通的值, 那么你应该使用它。</p>
</li>
</ol>
<p>举个例子：</p>
<pre><code>$scope.name = &apos;hello&apos;;

var watch = $scope.$watch(&apos;name&apos;,function(newValue,oldValue, scope){

    console.log(newValue);

    console.log(oldValue);

});

$timeout(function(){

    $scope.name = &quot;world&quot;;

},1000);
</code></pre><h3 id="watch性能问题"><a href="#watch性能问题" class="headerlink" title="watch性能问题"></a>watch性能问题</h3><p>太多的$watch将会导致性能问题，$watch如果不再使用，我们最好将其释放掉。</p>
<p>$watch函数返回一个注销监听的函数，如果我们想监控一个属性，然后在稍后注销它，可以使用下面的方式：</p>
<pre><code>var watch = $scope.$watch(&apos;someModel.someProperty&apos;, callback);

//...

//注销监听
watch();
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://474903784.github.io/2015/03/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
